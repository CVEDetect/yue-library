# 分布式缓存
Spring为我们提供了三大注解`@Cacheable`、`@CachePut`、`@CacheEvict`可在大部分场景下优雅实现分布式缓存。

## 注解介绍
注解介绍中所包含的代码片段位于[yue-library-test](https://gitee.com/yl-yue/yue-library/tree/master/yue-library-samples/yue-library-test)模块中

### @EnableCaching
一般注解在启动类或配置类上，表示启用缓存，使`@Cacheable`、`@CachePut`、`@CacheEvict`等注解生效。

### @Cacheable（添加/获取缓存）
|属性名				|作用																																													|
|--					|--																																														|
|cacheNames/value	|指定缓存的名字，缓存使用CacheManager管理多个缓存Cache，这些Cache就是根据该属性进行区分。对缓存的真正增删改查操作在Cache中定义，每个缓存Cache都有自己唯一的名字。						|
|key				|缓存数据时的key的值，默认是使用方法所有入参的值，可以使用SpEL表达式表示key的值。																										|
|keyGenerator		|缓存的生成策略（键生成器），和key二选一，作用是生成键值key，keyGenerator可自定义。																										|
|cacheManager		|指定缓存管理器(例如ConcurrentHashMap、Redis等)。																																		|
|cacheResolver		|和cacheManager作用一样，使用时二选一。																																					|
|condition			|指定缓存的条件（对参数判断，满足什么条件时才缓存），可用SpEL表达式，例如：方法入参为对象user则表达式可以写为`condition = "#user.age>18"`，表示当入参对象user的属性age大于18才进行缓存。|
|unless				|否定缓存的条件（对结果判断，满足什么条件时不缓存），即满足unless指定的条件时，对调用方法获取的结果不进行缓存，例如：`unless = "result==null"`，表示如果结果为null时不缓存。			|
|sync				|是否使用异步模式进行缓存，默认false。																																					|

以`cache_test`作为缓存名，参数`id`作为缓存key，如果命中缓存，直接返回结果。如果缓存不存在，就执行方法逻辑，并将方法的返回结果缓存。
```java
@Cacheable(value = "cache_test", key = "#id")
@GetMapping("/get")
public Result<?> get(Long id) {
	return R.success(jdbcDAO.get(id));
}
```

### @CachePut（更新缓存）
|属性名				|作用与描述																																												|
|--					|--																																														|
|cacheNames/value	|指定缓存的名字，缓存使用CacheManager管理多个缓存Cache，这些Cache就是根据该属性进行区分。对缓存的真正增删改查操作在Cache中定义，每个缓存Cache都有自己唯一的名字。						|
|key				|缓存数据时的key的值，默认是使用方法所有入参的值，可以使用SpEL表达式表示key的值。																										|
|keyGenerator		|缓存的生成策略（键生成器），和key二选一，作用是生成键值key，keyGenerator可自定义。																										|
|cacheManager		|指定缓存管理器(例如ConcurrentHashMap、Redis等)。																																		|
|cacheResolver		|和cacheManager作用一样，使用时二选一。																																					|
|condition			|指定缓存的条件（对参数判断，满足什么条件时才缓存），可用SpEL表达式，例如：方法入参为对象user则表达式可以写为condition = "#user.age>18"，表示当入参对象user的属性age大于18才进行缓存。	|
|unless				|否定缓存的条件（对结果判断，满足什么条件时不缓存），即满足unless指定的条件时，对调用方法获取的结果不进行缓存，例如：unless = "result==null"，表示如果结果为null时不缓存。				|

以`cache_test`作为缓存名，参数`id`作为缓存key，当方法逻辑执行完之后，将返回结果进行覆盖缓存。
```java
@CachePut(value = "cache_test", key = "#userGroupIPO.id")
@PutMapping("/put")
public Result<?> put(@Validated UserGroupIPO userGroupIPO) {
	jdbcDAO.updateById(Convert.toJSONObject(userGroupIPO));
	return R.success(jdbcDAO.get(userGroupIPO.getId()));
}
```

### @CacheEvict（删除缓存）
|属性名				|作用与描述																																																													|
|--					|--																																														|
|cacheNames/value	|指定缓存的名字，缓存使用CacheManager管理多个缓存Cache，这些Cache就是根据该属性进行区分。对缓存的真正增删改查操作在Cache中定义，每个缓存Cache都有自己唯一的名字。																							|
|key				|缓存数据时的key的值，默认是使用方法所有入参的值，可以使用SpEL表达式表示key的值。																																											|
|keyGenerator		|缓存的生成策略（键生成器），和key二选一，作用是生成键值key，keyGenerator可自定义。																																											|
|cacheManager		|指定缓存管理器(例如ConcurrentHashMap、Redis等)。																																																			|
|cacheResolver		|和cacheManager作用一样，使用时二选一。																																																						|
|condition			|指定删除缓存的条件（对参数判断，满足什么条件时才删除缓存），可用SpEL表达式，例如：入参为字符userId的方法删除缓存条件设定为当入参不是user001就删除缓存，则表达式可以写为condition = "!('user001').equals(#userId)"。										|
|allEntries			|allEntries是布尔类型的，用来表示是否需要清除缓存中的所有元素。默认值为false,表示不需要。当指定allEntries为true时，Spring Cache将忽略指定的key,清除缓存中的所有内容。																						|
|beforeInvocation	|清除操作默认是在对应方法执行成功后触发的（beforeInvocation = false），即方法如果因为抛出异常而未能成功返回时则不会触发清除操作。使用beforeInvocation属性可以改变触发清除操作的时间。当指定该属性值为true时，Spring会在调用该方法之前清除缓存中的指定元素。	|

以`cache_test`作为缓存名，参数`id`作为缓存key，当方法逻辑执行完之后，删除缓存。
```java
@CacheEvict(value = "cache_test", key = "#id")
@DeleteMapping("/delete")
public Result<?> delete(@RequestParam("id") Long id) {
	jdbcDAO.deleteLogic(id);
	return R.success();
}
```

### @EnableCaching
注解在类上面，可使`@Cacheable`、`@CachePut`、`@CacheEvict`注解无需定义重复的：`cacheNames/value、keyGenerator、cacheManager、cacheResolver`属性值


## 开始使用
在启动类或配置类加上`@EnableCaching`注解，表示启用缓存，使上面介绍的注解生效。


使用`@CacheConfig`注解，可以在类上


### 注解使用
上面介绍了注解的简单使用，在真实场景下需求多变，注解也同样需要进行灵活使用，结合`condition、unless`等条件可满足绝大部分场景下的缓存需求