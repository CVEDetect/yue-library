# 逻辑删除
> **逻辑删除与物理删除区别**
> - 表中的物理删除：将一条数据真实的进行删除，一般无法找回
> - 表中的逻辑删除：将一条数据标记为删除状态，实际数据任然存在表中，但数据理论上已被删除，不应该再被操作，因此需要在查询或更新数据时进行过滤

!> **逻辑删除只对自动生成的sql生效**

> **yue-jdbc中的逻辑删除**
> - 逻辑删除：调用逻辑删除方法（如：`deleteLogic(String tableName, Long id)`）删除数据
> - 逻辑删除过滤：在查询或更新数据时，需要对已被逻辑删除的数据进行过滤

逻辑删除是为了方便数据恢复和保护数据本身价值的一种方案，但实际就是删除。如果你的数据需要频繁查询并显示，请不要使用逻辑删除来表示，而是应该为数据添加一个业务状态字段来进行判断。

## 逻辑删除标识
yue-jdbc默认使用`delete_time`字段作为逻辑删除标识，字段类型约定如下：
- 在[DO类中](data/jdbc/DO基类.md)声明：`protected Long deleteTime`，使用时间戳类型，用`Long`进行存储，0表示未删除
- 在数据库中声明：MySQL DDL示例：`delete_time` bigint unsigned NOT NULL DEFAULT '0' COMMENT '删除时间戳：默认0（未删除）'

使用时间戳类型的好处是为了方便建立唯一索引，原因如下：
- 我们经常看到使用`Boolean`数据类型作为删除标识，这样做当表中需要存在多条已删除数据时，就无法建立唯一约束了，容易造成脏数据，引发业务异常
- 我们偶尔看到使用`DateTime`数据类型作为删除标识，这样做当数据未删除时，字段存在null值，容易引发不必要的错误与非空判断

## 逻辑删除过滤
启用逻辑删除过滤（只对自动生成的sql生效）后，查询或更新数据时会自动追加条件`delete_time = 0`，用于过滤已被逻辑删除的数据。

> 逻辑删除过滤SQL示例：
> - 删除：`UPDATE user SET delete_time = 1651745069477 WHERE id = 1` **` AND delete_time = 0`**
> - 修改：`UPDATE user SET name = ‘李四’ WHERE name = ‘张三’` **` AND delete_time = 0`**
> - 查询：`SELECT id,name,delete_time FROM user` **` WHERE delete_time = 0`**

### 全局配置
```yml
yue:
  jdbc:
    enable-logic-delete-filter: true                        # 启用逻辑删除过滤（只对自动生成的sql生效）
```

### 单个DAO配置
```java
public class DataJdbcExampleRepositoryDAO extends AbstractRepository<TableExampleTestDO> {

	@PostConstruct
	private void init() {
		db = db.clone();
		db.getJdbcProperties().setEnableLogicDeleteFilter(true);
	}
	
	...
}
```

## 逻辑删除方法
yue-jdbc提供单独的逻辑删除方法，而不是在逻辑删除与物理删除之间做转换，核心原因是出于安全考虑，具体如下：
- 通过一个配置开关来变更一个数据删除方法，是物理删除还是逻辑删除时，若出现误配置的情况，将出现不可挽回的损失（多环境维护时更容易出现误配置）
- 当物理删除和逻辑删除从方法调用上做根源分离后，便可彻底杜绝此类危险（可以认为是一种规范约束）

```java
/**
 * 逻辑删除
 * <p>数据非真实删除，而是更改 {@link JdbcProperties().getFieldDefinitionDeleteTime()} 字段值为时间戳，代表数据已删除
 *
 * @param tableName 表名
 * @param paramJson 条件
 * @return 删除所影响的行数
 */
public long deleteLogic(String tableName, JSONObject paramJson) {

/**
 * 逻辑删除-ById
 * <p>数据非真实删除，而是更改 {@link JdbcProperties().getFieldDefinitionDeleteTime()} 字段值为时间戳，代表数据已删除
 * <p><code style="color:red">依赖于接口传入 {@value DbConstant#FIELD_DEFINITION_PRIMARY_KEY} 参数时慎用此方法</code>，避免有序主键被遍历风险，造成数据越权行为。推荐使用 {@link #deleteLogicByUuid(String, String)}</p>
 * 
 * @param tableName	表名
 * @param id     	主键id
 */
public void deleteLogicById(String tableName, Long id) {

/**
 * 逻辑删除-By无序主键
 * <p>数据非真实删除，而是更改 {@link JdbcProperties().getFieldDefinitionDeleteTime()} 字段值为时间戳，代表数据已删除
 *
 * @param tableName 表名
 * @param uuidValue 无序主键的唯一值
 */
public void deleteLogicByUuid(String tableName, String uuidValue) {

/**
 * 逻辑删除-批量
 * <p>数据非真实删除，而是更改 {@link JdbcProperties().getFieldDefinitionDeleteTime()} 字段值为时间戳，代表数据已删除
 * <p>一组条件对应一条数据，并且每组条件都采用相同的key
 * 
 * @param tableName		表名
 * @param paramJsons	条件数组
 */
public void deleteBatchLogic(String tableName, JSONObject[] paramJsons) {

/**
 * 逻辑删除-批量（不调用 {@link #paramFormat(JSONObject)} 方法）
 * <p>数据非真实删除，而是更改 {@link JdbcProperties().getFieldDefinitionDeleteTime()} 字段值为时间戳，代表数据已删除
 * <p>一组条件对应一条数据，并且每组条件都采用相同的key
 *
 * @param tableName		表名
 * @param paramJsons	条件数组
 */
public void deleteBatchLogicNotParamFormat(String tableName, JSONObject[] paramJsons) {
```
